/* eslint-disable functional/no-let */
import {
  getMockEService,
  getMockDescriptorPublished,
  getMockDescriptor,
  getMockDocument,
  getMockAuthData,
  getMockDelegation,
  getMockContext,
} from "pagopa-interop-commons-test";
import {
  DescriptorId,
  Document,
  EService,
  EServiceId,
  delegationKind,
  delegationState,
  descriptorState,
  generateId,
  userRole,
} from "pagopa-interop-models";
import { beforeEach, describe, expect, it } from "vitest";
import { AuthData } from "pagopa-interop-commons";
import {
  addOneDelegation,
  addOneEService,
  catalogService,
} from "../integrationUtils.js";
import {
  eServiceDescriptorNotFound,
  eServiceNotFound,
} from "../../src/model/domain/errors.js";

const sortByUploadDate = (a: Document, b: Document): number =>
  a.uploadDate.getTime() - b.uploadDate.getTime();

describe("getDocuments", () => {
  beforeEach(async () => {
    // Adding a mock agreement to have some data other than the data generated by each test case
    await addOneEService(getMockEService());
    await addOneEService(getMockEService());
  });

  it("should get the documents for a published descriptor (requester is the producer, admin)", async () => {
    const mockEService: EService = {
      ...getMockEService(),
      descriptors: [
        {
          ...getMockDescriptorPublished(),
          docs: [getMockDocument(), getMockDocument()],
        },
      ],
    };

    await addOneEService(mockEService);

    const authData: AuthData = {
      ...getMockAuthData(mockEService.producerId),
      userRoles: [userRole.ADMIN_ROLE],
    };
    const result = await catalogService.getDocuments(
      mockEService.id,
      mockEService.descriptors[0].id,
      { offset: 0, limit: 10 },
      getMockContext({ authData })
    );

    expect(result).toEqual({
      results: mockEService.descriptors[0].docs.sort(sortByUploadDate),
      totalCount: mockEService.descriptors[0].docs.length,
    });
  });

  it.each([descriptorState.draft, descriptorState.waitingForApproval])(
    "should get the documents for a %s (requester is the producer, admin)",
    async (state) => {
      const mockEService: EService = {
        ...getMockEService(),
        descriptors: [
          {
            ...getMockDescriptor(),
            state,
            docs: [getMockDocument(), getMockDocument()],
          },
        ],
      };

      await addOneEService(mockEService);

      const authData: AuthData = {
        ...getMockAuthData(mockEService.producerId),
        userRoles: [userRole.ADMIN_ROLE],
      };
      const result = await catalogService.getDocuments(
        mockEService.id,
        mockEService.descriptors[0].id,
        { offset: 0, limit: 10 },
        getMockContext({ authData })
      );

      expect(result).toEqual({
        results: mockEService.descriptors[0].docs.sort(sortByUploadDate),
        totalCount: mockEService.descriptors[0].docs.length,
      });
    }
  );

  it("should get the documents (requester is the delegate, admin)", async () => {
    const mockEService: EService = {
      ...getMockEService(),
      descriptors: [
        {
          ...getMockDescriptorPublished(),
          docs: [getMockDocument(), getMockDocument()],
        },
      ],
    };

    const delegation = getMockDelegation({
      kind: delegationKind.delegatedProducer,
      eserviceId: mockEService.id,
      delegatorId: mockEService.producerId,
      state: delegationState.active,
    });

    await addOneEService(mockEService);
    await addOneDelegation(delegation);

    const authData: AuthData = {
      ...getMockAuthData(mockEService.producerId),
      userRoles: [userRole.ADMIN_ROLE],
    };
    const result = await catalogService.getDocuments(
      mockEService.id,
      mockEService.descriptors[0].id,
      { offset: 0, limit: 10 },
      getMockContext({ authData })
    );

    expect(result).toEqual({
      results: mockEService.descriptors[0].docs.sort(sortByUploadDate),
      totalCount: mockEService.descriptors[0].docs.length,
    });
  });

  it.each([descriptorState.draft, descriptorState.waitingForApproval])(
    "should throw eServiceNotFound if the e-service only has a %s descriptor (requester is not the producer, cannot view %s descriptors)",
    async (state) => {
      const mockEService: EService = {
        ...getMockEService(),
        descriptors: [
          {
            ...getMockDescriptor(),
            state,
            docs: [getMockDocument(), getMockDocument()],
          },
        ],
      };

      await addOneEService(mockEService);

      const authData: AuthData = {
        ...getMockAuthData(),
        userRoles: [userRole.ADMIN_ROLE],
      };
      await expect(
        catalogService.getDocuments(
          mockEService.id,
          mockEService.descriptors[0].id,
          { offset: 0, limit: 10 },
          getMockContext({ authData })
        )
      ).rejects.toThrowError(eServiceNotFound(mockEService.id));
    }
  );

  it.each([descriptorState.draft, descriptorState.waitingForApproval])(
    "should throw eServiceDescriptorNotFound if the descriptor is %s (requester is not the producer, cannot view %s descriptors)",
    async (state) => {
      const mockEService: EService = {
        ...getMockEService(),
        descriptors: [
          getMockDescriptorPublished(),
          {
            ...getMockDescriptor(),
            state,
            docs: [getMockDocument(), getMockDocument()],
          },
        ],
      };

      await addOneEService(mockEService);

      const authData: AuthData = {
        ...getMockAuthData(),
        userRoles: [userRole.ADMIN_ROLE],
      };
      await expect(
        catalogService.getDocuments(
          mockEService.id,
          mockEService.descriptors[1].id,
          { offset: 0, limit: 10 },
          getMockContext({ authData })
        )
      ).rejects.toThrowError(
        eServiceDescriptorNotFound(
          mockEService.id,
          mockEService.descriptors[1].id
        )
      );
    }
  );

  it.each([descriptorState.draft, descriptorState.waitingForApproval])(
    "should throw eServiceNotFound if the e-service only has a %s descriptor (requester is the producer, but role cannot view %s descriptors)",
    async (state) => {
      const mockEService: EService = {
        ...getMockEService(),
        descriptors: [
          {
            ...getMockDescriptor(),
            state,
            docs: [getMockDocument(), getMockDocument()],
          },
        ],
      };

      await addOneEService(mockEService);

      const authData: AuthData = {
        ...getMockAuthData(mockEService.producerId),
        userRoles: [userRole.SECURITY_ROLE],
      };
      await expect(
        catalogService.getDocuments(
          mockEService.id,
          mockEService.descriptors[0].id,
          { offset: 0, limit: 10 },
          getMockContext({ authData })
        )
      ).rejects.toThrowError(eServiceNotFound(mockEService.id));
    }
  );

  it.each([descriptorState.draft, descriptorState.waitingForApproval])(
    "should throw eServiceDescriptorNotFound if the descriptor is %s (requester is the producer, but role cannot view %s descriptors)",
    async (state) => {
      const mockEService: EService = {
        ...getMockEService(),
        descriptors: [
          getMockDescriptorPublished(),
          {
            ...getMockDescriptor(),
            state,
            docs: [getMockDocument(), getMockDocument()],
          },
        ],
      };

      await addOneEService(mockEService);

      const authData: AuthData = {
        ...getMockAuthData(mockEService.producerId),
        userRoles: [userRole.SECURITY_ROLE],
      };
      await expect(
        catalogService.getDocuments(
          mockEService.id,
          mockEService.descriptors[1].id,
          { offset: 0, limit: 10 },
          getMockContext({ authData })
        )
      ).rejects.toThrowError(
        eServiceDescriptorNotFound(
          mockEService.id,
          mockEService.descriptors[1].id
        )
      );
    }
  );

  it("should throw eServiceNotFound if the eservice doesn't exist", async () => {
    const eserviceId = generateId<EServiceId>();
    await expect(
      catalogService.getDocuments(
        eserviceId,
        generateId<DescriptorId>(),
        { offset: 0, limit: 10 },
        getMockContext({})
      )
    ).rejects.toThrowError(eServiceNotFound(eserviceId));
  });

  it("should throw eServiceDescriptorNotFound if the descriptor doesn't exist (requester is the producer, admin)", async () => {
    const mockEService: EService = {
      ...getMockEService(),
      descriptors: [getMockDescriptorPublished()],
    };
    await addOneEService(mockEService);
    const descriptorId = generateId<DescriptorId>();
    await expect(
      catalogService.getDocuments(
        mockEService.id,
        descriptorId,
        { offset: 0, limit: 10 },
        getMockContext({})
      )
    ).rejects.toThrowError(
      eServiceDescriptorNotFound(mockEService.id, descriptorId)
    );
  });
});
