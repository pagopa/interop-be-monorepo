/* eslint-disable functional/no-let */
import { generateMock } from "@anatine/zod-mock";
import {
  addSomeRandomDelegations,
  getMockAgreement,
  getMockDelegation,
  getMockEService,
  getMockTenant,
  getMockDescriptorPublished,
  getMockContextM2M,
} from "pagopa-interop-commons-test";
import {
  Agreement,
  AgreementDocument,
  AgreementId,
  TenantId,
  delegationKind,
  delegationState,
  generateId,
} from "pagopa-interop-models";
import { beforeEach, describe, expect, it } from "vitest";
import {
  agreementNotFound,
  tenantNotAllowed,
} from "../../src/model/domain/errors.js";
import {
  addOneAgreement,
  addOneDelegation,
  addOneEService,
  addOneTenant,
  agreementService,
} from "../integrationUtils.js";

const sortByCreatedAt = (a: AgreementDocument, b: AgreementDocument): number =>
  a.createdAt.getTime() - b.createdAt.getTime();

describe("getAgreementConsumerDocuments", () => {
  beforeEach(async () => {
    // Adding a mock agreement to have some data other than the data generated by each test case
    await addOneAgreement(getMockAgreement());
    await addOneAgreement(getMockAgreement());
  });

  it("should succeed when the requester is the consumer", async () => {
    const agreement: Agreement = {
      ...getMockAgreement(),
      consumerDocuments: [
        generateMock(AgreementDocument),
        generateMock(AgreementDocument),
      ],
    };
    await addOneAgreement(agreement);
    const result = await agreementService.getAgreementConsumerDocuments(
      agreement.id,
      { offset: 0, limit: 10 },
      getMockContextM2M({
        organizationId: agreement.consumerId,
      })
    );
    expect(result).toEqual({
      results: agreement.consumerDocuments.sort(sortByCreatedAt),
      totalCount: agreement.consumerDocuments.length,
    });
  });

  it("should succeed when the requester is the producer", async () => {
    const agreement: Agreement = {
      ...getMockAgreement(),
      consumerDocuments: [
        generateMock(AgreementDocument),
        generateMock(AgreementDocument),
      ],
    };
    await addOneAgreement(agreement);
    const result = await agreementService.getAgreementConsumerDocuments(
      agreement.id,
      { offset: 0, limit: 10 },
      getMockContextM2M({
        organizationId: agreement.producerId,
      })
    );
    expect(result).toEqual({
      results: agreement.consumerDocuments.sort(sortByCreatedAt),
      totalCount: agreement.consumerDocuments.length,
    });
  });

  it("should succeed when the requester is the producer delegate", async () => {
    const producer = getMockTenant();
    const consumer = getMockTenant();
    const delegate = getMockTenant();
    const eservice = {
      ...getMockEService(),
      producerId: producer.id,
      consumerId: consumer.id,
      descriptors: [getMockDescriptorPublished()],
    };
    const agreement = {
      ...getMockAgreement(eservice.id),
      descriptorId: eservice.descriptors[0].id,
      producerId: producer.id,
      consumerId: consumer.id,
      consumerDocuments: [
        generateMock(AgreementDocument),
        generateMock(AgreementDocument),
      ],
    };
    const delegation = getMockDelegation({
      kind: delegationKind.delegatedProducer,
      delegateId: delegate.id,
      eserviceId: eservice.id,
      delegatorId: eservice.producerId,
      state: delegationState.active,
    });

    await addOneTenant(delegate);
    await addOneEService(eservice);
    await addOneAgreement(agreement);
    await addOneDelegation(delegation);
    await addSomeRandomDelegations(agreement, addOneDelegation);

    const result = await agreementService.getAgreementConsumerDocuments(
      agreement.id,
      { offset: 0, limit: 10 },
      getMockContextM2M({
        organizationId: delegate.id,
      })
    );

    expect(result).toEqual({
      results: agreement.consumerDocuments.sort(sortByCreatedAt),
      totalCount: agreement.consumerDocuments.length,
    });
  });

  it("should succeed when the requester is the consumer delegate", async () => {
    const producer = getMockTenant();
    const consumer = getMockTenant();
    const delegate = getMockTenant();
    const eservice = {
      ...getMockEService(),
      producerId: producer.id,
      consumerId: consumer.id,
      descriptors: [getMockDescriptorPublished()],
    };
    const agreement = {
      ...getMockAgreement(eservice.id),
      descriptorId: eservice.descriptors[0].id,
      producerId: producer.id,
      consumerId: consumer.id,
      consumerDocuments: [
        generateMock(AgreementDocument),
        generateMock(AgreementDocument),
      ],
    };
    const delegation = getMockDelegation({
      kind: delegationKind.delegatedConsumer,
      delegateId: delegate.id,
      eserviceId: eservice.id,
      delegatorId: eservice.consumerId,
      state: delegationState.active,
    });
    await addOneTenant(delegate);
    await addOneEService(eservice);
    await addOneAgreement(agreement);
    await addOneDelegation(delegation);
    await addSomeRandomDelegations(agreement, addOneDelegation);

    const result = await agreementService.getAgreementConsumerDocuments(
      agreement.id,
      { offset: 0, limit: 10 },
      getMockContextM2M({
        organizationId: delegate.id,
      })
    );

    expect(result).toEqual({
      results: agreement.consumerDocuments.sort(sortByCreatedAt),
      totalCount: agreement.consumerDocuments.length,
    });
  });

  it("should succeed when the requester is the consumer, even if there is an active consumer delegation", async () => {
    const agreement = {
      ...getMockAgreement(),
      consumerDocuments: [generateMock(AgreementDocument)],
    };

    const delegation = getMockDelegation({
      kind: delegationKind.delegatedConsumer,
      eserviceId: agreement.eserviceId,
      delegatorId: agreement.consumerId,
      delegateId: generateId<TenantId>(),
      state: delegationState.active,
    });

    await addOneAgreement(agreement);
    await addOneDelegation(delegation);

    const result = await agreementService.getAgreementConsumerDocuments(
      agreement.id,
      { offset: 0, limit: 10 },
      getMockContextM2M({
        organizationId: agreement.consumerId,
      })
    );

    expect(result).toEqual({
      results: agreement.consumerDocuments.sort(sortByCreatedAt),
      totalCount: agreement.consumerDocuments.length,
    });
  });

  it("should apply pagination correctly", async () => {
    const agreement: Agreement = {
      ...getMockAgreement(),
      consumerDocuments: [
        generateMock(AgreementDocument),
        generateMock(AgreementDocument),
        generateMock(AgreementDocument),
        generateMock(AgreementDocument),
        generateMock(AgreementDocument),
      ],
    };

    const ctx = getMockContextM2M({
      organizationId: agreement.consumerId,
    });

    await addOneAgreement(agreement);
    const result1 = await agreementService.getAgreementConsumerDocuments(
      agreement.id,
      { offset: 0, limit: 2 },
      ctx
    );

    expect(result1).toEqual({
      results: agreement.consumerDocuments.sort(sortByCreatedAt).slice(0, 2),
      totalCount: agreement.consumerDocuments.length,
    });

    const result2 = await agreementService.getAgreementConsumerDocuments(
      agreement.id,
      { offset: 2, limit: 2 },
      ctx
    );

    expect(result2).toEqual({
      results: agreement.consumerDocuments.sort(sortByCreatedAt).slice(2, 4),
      totalCount: agreement.consumerDocuments.length,
    });

    const result3 = await agreementService.getAgreementConsumerDocuments(
      agreement.id,
      { offset: 4, limit: 2 },
      ctx
    );
    expect(result3).toEqual({
      results: agreement.consumerDocuments.sort(sortByCreatedAt).slice(4, 5), // Only one document left
      totalCount: agreement.consumerDocuments.length,
    });
  });

  it("should succeed when the requester is the producer, even if there is an active producer delegation", async () => {
    const agreement = {
      ...getMockAgreement(),
      consumerDocuments: [generateMock(AgreementDocument)],
    };

    const delegation = getMockDelegation({
      kind: delegationKind.delegatedProducer,
      eserviceId: agreement.eserviceId,
      delegatorId: agreement.producerId,
      delegateId: generateId<TenantId>(),
      state: delegationState.active,
    });

    await addOneAgreement(agreement);
    await addOneDelegation(delegation);

    const result = await agreementService.getAgreementConsumerDocuments(
      agreement.id,
      { offset: 0, limit: 10 },
      getMockContextM2M({
        organizationId: agreement.producerId,
      })
    );

    expect(result).toEqual({
      results: agreement.consumerDocuments.sort(sortByCreatedAt),
      totalCount: agreement.consumerDocuments.length,
    });
  });

  it("should throw an agreementNotFound error when the agreement does not exist", async () => {
    const randomAgreementId = generateId<AgreementId>();

    await expect(
      agreementService.getAgreementConsumerDocuments(
        randomAgreementId,
        { offset: 0, limit: 10 },
        getMockContextM2M({})
      )
    ).rejects.toThrowError(agreementNotFound(randomAgreementId));
  });

  it("should throw an tenantNotAllowed error when the requester is not the consumer or producer", async () => {
    const agreement: Agreement = {
      ...getMockAgreement(),
      consumerDocuments: [
        generateMock(AgreementDocument),
        generateMock(AgreementDocument),
      ],
    };

    await addOneAgreement(agreement);

    const randomTenantId = generateId<TenantId>();
    await expect(
      agreementService.getAgreementConsumerDocuments(
        agreement.id,
        { offset: 0, limit: 10 },
        getMockContextM2M({
          organizationId: randomTenantId,
        })
      )
    ).rejects.toThrowError(tenantNotAllowed(randomTenantId));
  });
});
